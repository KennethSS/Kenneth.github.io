---
layout: default
title: SOLID 원칙
parent: Principle
grand_parent: CS
permalink: /docs/cs/principle/solid-principle/


---

# SOLID 원칙

## SOLID 원칙 이란?

**SOLID 원칙**이란 객체지향 설계에 5대 원칙으로 2000년대 초반 로버트 마틴이 소개한 것을 마이클 페더스가 줄임말로 소개하여 널리 알려지게 되었다. SOLID 원칙의 목적은 가독성이 좋고 유지보수와 확장이 쉬운 시스템을 만들고 리팩토링하는 것에 목적이 있다. SOLID 원칙에는 5가지로 구성되어있다.

1. 단일 책임 원칙(Single Responsibility Principle)
2. 개방-폐쇄 원칙(Open Closed Principle)
3. 리스코프 치환 원칙(Liskov Substitution Principle)
4. 인터페이스 분리 원칙(Interface Segregation Principle)
5. 의존 역전 원칙(Dependency Inversion Principle)



### 1. 단일 책임 원칙(Single Responsibility Principle)

모든 클래스는 하나의 책임만 가져야 하며, 클래스는 책임을 완전히 캡슐화 해야함을 말한다.

데이터를 분석하고 서버에 전송하는 클래스 혹은 모듈이가 있다고 가정할 때 데이터 분석 알고리즘이 변경될 수 있고, 서버에 전송하는 형태가 변경 될 수 있다. 단일 책임 원칙에서는 이 형태는 2개의 분리된 책임으로 볼 수 있고 그 책임을 클래스나 모듈로서 분리해야 한다.

### 2. 개방-폐쇄 원칙(Open Closed Principle)

소프트웨어가 확장에는 열려있고 수정에 대해서는 닫혀있어야 한다는 원칙이다. 

어떤 내용을 수정하기 위해 연관된 다른 코드들까지 모두 수정하는 것은 어려운 일이다. 이를 만족하기 위해서는 캡슐화를 통해 여러 객체에서 사용하는 기능을 인터페이스에 정의하여 해결하는 방법이 있습니다. 

### 3. 리스코프 치환 원칙(Liskov Substitution Principle)

자식 클래스는 언제나 부모 클래스를 대체할 수 있다는 원칙이다. 기존 부모 클래스에 들어갈 자리에 자식 클래스를 치환하여 대입하여도 문제없이 잘 동작해야 한다.

자식 클래스는 부모 클래스의 책임을 무시하거나 기능들을 재정의하지 않고 ''확장'만 수행하도록 해야한다.

### 4. 인터페이스 분리 원칙(Interface Segregation Principle)

어떠한 클래스가 자신이 이용하지 않는 메서드에 의존하지 않고 큰 덩어리의 인터페이스들을 구체적이고 작은 단위의 인터페이스로 분리해 해당 클래스들이 꼭 필요한 메서드들만 이용할 수 있게 하는 것 입니다.

### 5. 의존 역전 원칙(Dependency Inversion Principle)

객체 지향 프로그래밍에서 의존 역전 원칙은 모듈들을 분리하는 특정 형식을 지칭한다. 이 원칙을 따르면, 상위 계층이 하위 계층에 의존하는 관계를 역전 시킴으로써 상위 계층이 하위 계층의 구현으로부터 독립되게 할 수 있다. 이 원칙은 다음과 같은 내용을 담고 있다.

- 상위 모듈은 하위 모듈에 의존해서는 안된다. 상위 모듈과 하위 모듈 모두 **추상화**에 의존해야 한다.
- **추상화**는 세부 사항에 의존해서는 안된다. 세부사항이 추상화에 의존해야 한다.

여기서 말하는 추상화는 인터페이스를 활용해서 구현할 수 있다. 구체적인 클래스에 의존하는 것보다 인터페이스나 추상 클래스에 의존하여 세부사항에 의존하지않고 상위, 하위 모듈 모두 추상화에 의존하는것을 목적에 두고 있다.



